---
title: "Tagless-final + EffでExcelシートをパーズする"
emoji: "🧾"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["scala", "excel", "eff", "taglessfinal", "関数型プログラミング"]
published: false
---

# はじめに

過去の[Tagless-final + EffなScalaによるExcelパーザー](https://zenn.dev/yyu/articles/61799662c042ac.md)はTagless-finalやExtensible Effectsを駆使したExcelパーザーを作成したが、これはあくまでも1つの行を狙ってパーズするようになっていた。

```scala
case class HelloExcel(
  a1: String,
  a2: Option[String],
  a3: Double,
  a4: List[String]
)

val actual = ExcelRowReads[R, HelloExcel]
  .parse
  .runReader(row)
  .evalState(0)
  .run
```

このようなコードで次のようなExcelシートをパーズできる。

![](https://storage.googleapis.com/zenn-user-upload/dfe511be63cb-20220124.png =500x)
*図1. 1種類の行データで構成されたExcelシート*

このままでも使えるが、ExcelはCSVなどの完全なデータフォーマットとは少し違って人間が入力するため、たとえば次の画像のように行ごとに異なるパターンのデータが挿入されていることもある。

![](https://storage.googleapis.com/zenn-user-upload/4a2058d8da54-20220124.png =500x)
*図2. 複数のフォーマットを内包したExcelシート*

そういった事情を考慮して、より使いやすくするために行ではなくExcelのシートを直接パーズできるような`ExcelSheetReads`の追加を行った。この記事では`ExcelSheetReads`の構造について解説する。また、今回の対応にあたってついでにExcelパーザーのソースコード全体をScala 3対応したので、それについても少し紹介する。
この記事で紹介するコードは簡単のため一部を抜き出すなどの加工をしているが、完全なものが下記のGitHubリポジトリーに置かれている。

- https://github.com/y-yu/excel-reads

この記事を読んで疑問や改善点などがあると思った場合、気軽にコメントなどで教えてほしい。

# 使い方

先程の図（2）のようなシートを`ExcelSheetReads`は次のようにパーズできる。

```scala
case class Header(
  a1: String,
  a2: String,
  a3: Int,
  a4: Boolean
)

val workbook = WorkbookFactory.create(
  new File("/test.xlsx")
)
val sheet = ApachePoiSheet(workbook.getSheet("Sheet1"))

val actual = ExcelSheetReads
  .parse[
    R, // Effect stack
    Header,
    List[Int],
    Optional[Boolean],
    SkipOnlyEmpties, 
    (String, String)
  ]
  .runReader(ApachePoiSheet(sheet))
  .evalState(0)
  .runEither
  .run
```

```scala
(
  Header("Hello", "Excel", 1, true),
  List(1, 2, 3, 4, 5),
  Some(true),
  1, // スキップした行数
  ("Good", "Bye!")
)
```

このように型パラメーターとして行の構造となる型を指定できるうえ、`Optional`や`SkipOnlyEmpties`など同じフォーマットの行が何個くらい続く可能性があるかも型で指定できるようになっている。
さらに、次の画像にあるシートように特定のデータが繰り返されるようなシートは次のように`ExcelSheetReads.loop`でパーズできる。

![](https://storage.googleapis.com/zenn-user-upload/b8d586a60667-20220130.png =500x)

```scala
val actual = ExcelSheetReads
  .loop[
    R,
    List[String],
    List[Int]
  ]
  .runReader(ApachePoiSheet(sheet))
  .evalState(0)
  .runEither
  .run
```

```scala
List(
  (List("Hello", "Excel"), List(1, 2, 3)),
  (List("This", "is", "a", "pen."), List(9, 8, 7, 6))
)
```

# 型クラス`ExcelSheetReads`

Excelシートをパーズするための型クラス`ExcelSheetReads`は次のようになる。

```scala:ExcelSheetReads.scala
abstract class ExcelSheetReads[R, A] { self =>
  type Result

  def parse(implicit
    m1: State[Int, *] |= R,
    m2: Either[ExcelParseErrors, *] |= R
  ): Eff[R, Result]
}
```

行をパーズする`ExcelRowReads`[^rename]と比べて、返り値が型メンバーとして各インスタンスで具体的に与えられるのが特徴的となっている。
また、インスタンスを作る際の便利メソッド`from`を次のように作っておく。

[^rename]: 前回の記事では`ExcelReads`という名前であったが、シートをパーズする存在が生じたため`ExcelReads`が行をパーズするのかどうか分かりにくくなると考え、名前を`ExcelRowReads`とより行への指向性を強調した名前へと変更した。

```scala:ExcelSheetReads.scala
object ExcelSheetReads {

  def from[R, A, B](
    f: State[Int, *] |= R => Either[ExcelParseErrors, *] |= R => Eff[R, B]
  ): ExcelSheetReads[R, A] = new ExcelSheetReads[R, A] {
    type Result = B

    def parse(implicit
      m1: State[Int, *] |= R,
      m2: Either[ExcelParseErrors, *] |= R
    ): Eff[R, B] =
      f(m1)(m2)
  }
}
```

`from`の第1・第2型パラメーターは`ExcelSheetReads`の型パラメーターとして利用され、そして第3パラメーターは`ExcelSheetReads.parse`の返り値の型となる型メンバー`Result`として利用される。

# Excel行に対するインターフェース

Excelの行に対するパーズでは、行データからセルに関する情報を取得するため、Tagless-finalスタイルで記述された`ExcelBasicSYM`などのインターフェースが存在した。これと同様にExcelシートに対して、特定の行に対する操作のインターフェースとして次のような`ExcelRowSYM`を定義する[^either]。

```scala:ExcelRowSYM.scala
abstract class ExcelRowSYM[Row, R, F[_]: Monad] {
  def isEmpty: F[Boolean]

  def isEnd: F[Boolean]

  def getRow: F[Row]

  def withRow[A](
    reads: ExcelRowReads[R, A]
  ): F[Either[ExcelParseErrors, A]]
}
```

`withRow`が多少非自明な型となっている。`withRow`は次のような振る舞いとなる。

- `reads`によるパーズが成功した場合はその結果である`F[Right[A]]`な値を返す
- `reads`によるパーズが失敗した場合は`F[Left[ExcelParseErrors]]`を返す

[^either]: 前回の記事の状態と比較して、`Eff`の結果の型にあった`ValidatedNel[ExcelParseError, *]`はエフェクトスタック`R`へと移動させ、その関係でアプリカティブというよりもモナドな`Either[NonEmptyList[ExcelParseError], *]`となっている。なお`ExcelParseErrors`は`NonEmptyList[ExcelParseError]`のエイリアスである。

また、`ExcelRowSYM`などと比べて型パラメーターが多いが、これは`ExcelSheetReads`のインスタンスを説明するときに解説する。

# 型パラメーターによる行データ指定

`ExcelSheetReads.loop`/`.parse`はどちらも型パラメーターとして行を表すデータ構造を受け取り、それに従って行をパーズしていく。まずはこのメカニズムがどうなっているのか？について解説する。
`ExcelSheetReads.loop`/`.parse`は主に次の2種類の型をパーズすべき行データとして受け取ることができる。

1. 行を表す任意のデータ型`A`（= `ExcelRowReads[R, A]`のインスタンスが存在する）
2. 空行や繰り返しなどの特殊な型

これら2パターンについて順番に説明する。

## `ExcelRowReads`を利用した1行のパーズ

`ExcelRowSYM`で定義した`withRow`と便利メソッド`from`を利用すれば、次のように書ける。

```scala
implicit def aInstance[Row, R, U, A](implicit
  sym: ExcelRowSYM[Row, U, Eff[R, *]],
  reads: ExcelRowReads[U, A]
): ExcelSheetReads[R, A] =
  ExcelSheetReads.from[R, A, A] { implicit m1 => implicit m2 =>
    for {
      s <- get
      a <- sym.withRow(reads).flatMap(fromEither[R, ExcelParseErrors, A])
      _ <- put(s + 1)
    } yield a
  }
```

ここで`ExcelRowSYM`の型パラメーターについて説明が必要になる。`ExcelRowSYM[Row, U, Eff[R, *]]`は上記のように3つの型パラメーターを取っているが、2番目の型パラメーターが必要となるのは`withRow`のみであるから、次のように`withRow`の型パラメーターにしてもよいように見える。

```scala
def withRow[R, A](
  reads: ExcelRowReads[R, A]
): F[Either[ExcelParseErrors, A]]
```

しかし、このようにすると`sym: ExcelRowSYM[Row, U, Eff[R, *]]`と`reads: ExcelRowReads[U, A]`が同じ`U`であることを保証できなくなってしまう。したがってこのようにimplicitパラメーター`sim`が探索されたと同時に、同じ型パラーメーターに対応する`reads`を探索させるためにインターフェースから型を注入する設計とならざるを得ない。

## 空行や繰り返しのパーズ

次に空行や繰り返しのパーズを説明する。

### 空行や繰り返しなどを表す型： `ExcelRowQuantifier`

空行などを表すために、次のような特殊な型が用意されている。

```scala:ExcelRowQuantifier.scala
object ExcelRowQuantifier {
  case class Optional[A]()

  case class Many[A]()

  case class Skip()

  case class SkipOnlyEmpties()

  case class End()
}
```

これらについて簡単な説明を与える。

| `ExcelRowQuantifier` | 効果 |
|----------------------|------|
|`Optional[A]`         |Excel行がデータ型`A`としてパーズできる、または空行|
|`Many[A]`             |データ型`A`としてパーズできる行が0以上の任意の回数繰り返す|
|`Skip`                |現在の行をパーズせずにスキップする|
|`SkipOnlyEmpties`     |空行をスキップする|
|`End`                 |Excelシートの終端行にマッチする|

さて、これらのインスタンス定義について見ていく。

### `ExcelSheetReads[R, ExcelRowQuantifier]`インスタンス定義

#### `End`と`Skip`

これら2つは比較的簡単なのでまずはこれらから見ていく。

```scala:ExcelSheetReadsInstances.scala
implicit def endInstance[Row, R, A](implicit
  sym: ExcelRowSYM[Row, _, Eff[R, *]]
): ExcelSheetReads[R, End] =
  ExcelSheetReads.from[R, End, Boolean] { implicit m1 => implicit m2 =>
    for {
      isEmptyAndEnd <- sym.isEmpty product sym.isEnd
    } yield isEmptyAndEnd._1 && isEmptyAndEnd._2
  }
```

このように`ExcelRowSYM`の`isEmpty`と`isEnd`を`&&`するだけである。`ExcelSheetReads[R, End]`はパーズ結果として`from`の第3型パラメーターである`Boolean`を出力する。これは終端行であれば`true`であり、そうでなければ`false`となるためである。

次に`ExcelSheetReads[R, Skip]`について見ていく。

```scala:ExcelSheetReadsInstances.scala
implicit def skipInstance[Row, R, A]: ExcelSheetReads[R, Skip] =
  ExcelSheetReads.from[R, Skip, Unit] { implicit m1 => implicit m2 =>
    for {
      s <- get
      _ <- put(s + 1)
    } yield ()
  }
```

このようにパーズは行わず`Eff`にステートモナドとして埋め込まれた行のカウンターをインクリメントさせるだけとなっている。

### `SkipOnlyEmpties`

このあたりから再帰を利用した面倒なインスタンスになっていく。

```scala:ExcelSheetReadsInstances.scala
implicit def skipOnlyEmptiesInstance[Row, R, A](implicit
  sym: ExcelRowSYM[Row, _, Eff[R, *]]
): ExcelSheetReads[R, SkipOnlyEmpties] = {
  def loop(
    skipLineCount: Int
  )(implicit
    m1: State[Int, *] |= R,
    m2: Either[ExcelParseErrors, *] |= R
  ): Eff[R, Int] =
    for {
      s <- get
      isEmptyAndEnd <- sym.isEmpty product sym.isEnd
      result <-
        if (isEmptyAndEnd._1 && !isEmptyAndEnd._2) {
          put(s + 1) >> loop(skipLineCount + 1)
        } else {
          Eff.pure[R, Int](skipLineCount)
        }
    } yield result

  ExcelSheetReads.from[R, SkipOnlyEmpties, Int] { implicit m1 => implicit m2 =>
    loop(0)
  }
}
```

このように、現在の行が`isEmpty == true`かつ`isEnd == false`であれば行カウンターをインクリメントする、という操作を再帰的に実行する。そして結果としてスキップした行数（`Int`）をパーズ結果として返すようになっている。

#### `Optional[A]`

`Optional[A]`は現在の行カウンターから読み込んだデータを型`A`としてパーズできるか試み、可能であれば`Some[A]`となり失敗であれば`None`となる。したがって結果の型は`Option[A]`となる。

```scala:ExcelSheetReadsInstances.scala
implicit def optionalInstance[Row, R, U, A](implicit
  sym: ExcelRowSYM[Row, U, Eff[R, *]],
  reads: ExcelRowReads[U, A]
): ExcelSheetReads[R, Optional[A]] =
  ExcelSheetReads.from[R, Optional[A], Option[A]] { implicit m1 => implicit m2 =>
    for {
      s <- get
      isEmpty <- sym.isEmpty
      result <-
        if (isEmpty) {
          Option.empty[A].pureEff[R]
        } else {
          for {
            ae <- sym.withRow(reads)
            result <- Eff.traverseA(ae) { a =>
              put(s + 1).map(_ => a)
            }
          } yield result.fold(
            _ => Option.empty[A],
            x => Option(x)
          )
        }
    } yield result
  }
```

#### `Many[A]`

最後のインスタンスである`ExcelSheetReads[R, Many[A]]`は次のように既存の2つのインスタンスを足したような複雑なものとなる。

- `Optional[A]`のインスタンスのように型パラメーター`A`の`ExcelRowReads`インスタンスを利用し
- `SkipOnlyEmpties`のインスタンスのように再帰関数を利用する

```scala:ExcelSheetReadsInstances.scala
implicit def manyInstance[Row, R, U, A](implicit
  sym: ExcelRowSYM[Row, U, Eff[R, *]],
  reads: ExcelRowReads[U, A]
): ExcelSheetReads[R, Many[A]] = {
  def loop(
    as: Seq[A]
  )(implicit
    m1: State[Int, *] |= R,
    m2: Either[ExcelParseErrors, *] |= R
  ): Eff[R, Seq[A]] =
    for {
      s <- get
      isEmpty <- sym.isEmpty
      result <-
        if (isEmpty) {
          as.pureEff[R]
        } else {
          for {
            ae <- sym.withRow(reads)
            result <- Eff.traverseA(ae) { a =>
              put(s + 1) >> loop(as :+ a)
            }
          } yield result.fold(
            { _ => as },
            identity
          )
        }
    } yield result

  ExcelSheetReads.from[R, Many[A], Seq[A]] { implicit m1 => implicit m2 =>
    loop(Seq.empty[A])
  }
}
```

# Excelシートを与えられた型で繰り返しパーズ

ここからは`ExcelSheetReads.loop`について説明する。実はこれは`loop`関数が型パラメーターの数ごとにオーバーロードするというゴリ押しとなっている。たとえば4行の場合は次のようになる[^asInstanceOf]。

```scala:ExcelSheetReadsParseLoop.scala
def loop[R: _state: _either, A, B, C, D](implicit
  end: ExcelSheetReads[R, End],
  r1: ExcelSheetReads[R, A],
  r2: ExcelSheetReads[R, B],
  r3: ExcelSheetReads[R, C],
  r4: ExcelSheetReads[R, D]
): Eff[R, Seq[(r1.Result, r2.Result, r3.Result, r4.Result)]] =
  loopInternal[R, (((A, B), C), D), (r1.Result, r2.Result, r3.Result, r4.Result)](
    r1 andThen r2 andThen r3 andThen r4
  ) {
    _.asInstanceOf[(((r1.Result, r2.Result), r3.Result), r4.Result)] match {
      case (((a, b), c), d) => (a, b, c, d)
    }
  }
```

[^asInstanceOf]: なぜかここは`asInstanceOf`をするしかなかった……。

このようにボイラープレートをなるべく抑えるために次のような`loopInternal`/`loop1`を相互再帰で利用している。

```scala
private def loopInternal[R, A, B](
  reads: ExcelSheetReads[R, A]
)(
  transform: reads.Result => B
)(implicit
  m1: State[Int, *] |= R,
  m2: Either[ExcelParseErrors, *] |= R,
  end: ExcelSheetReads[R, End]
): Eff[R, Seq[B]] =
  for {
    isEnd <- end.parse
    // This `isEnd`s pattern-matching is not rewritable instead of `if`.
    // The type of `isEnd` is not `Boolean`, it's `end.Result`,
    // so we have to fix that the `end.Result` is `Boolean` using pattern-matching.
    result <- isEnd match {
      case true =>
        Seq.empty.pureEff[R]
      case false =>
        for {
          a <- reads.parse
          // This mutual recursion is required by detecting the `ts` type is `Seq[reads.Result]`.
          ts <- loop1(m1, m2, end, reads)
        } yield a +: ts
    }
  } yield result.map(transform)

private def loop1[R: _state: _either, A](implicit
  end: ExcelSheetReads[R, End],
  r1: ExcelSheetReads[R, A]
): Eff[R, Seq[r1.Result]] =
  loopInternal[R, A, r1.Result](r1)(x => x)
```

# Scala 3対応

前回の記事の段階ではScala 3への対応はされていなかったため、shapelessを利用したマクロ部分がコンパイル不可能であった。その部分は`ExcelRowReadsGenericInstances`として切り出してScala 2とScala 3で別々に用意することでScala 3でもコンパイル可能にした。説明が難しいので、興味がある場合は下記のコードを実際に見てほしい。

- https://github.com/y-yu/excel-reads/blob/master/core/src/main/scala-3/excelreads/ExcelRowReadsGenericInstances.scala

# まとめ

前回の記事から結構大きく改造したが、これでExcelパーザーは機能的には最終的に完成したと思う。ただ一部`asInstanceOf`を利用せざるを得なくなってしまったのが残念なので、技術的な課題としてこれを消去しても動くようにするというのが残されている。