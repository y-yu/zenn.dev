---
title: "ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã•ã‚ŒãŸEffä¸Šã®ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã—State"
emoji: "ğŸ§¬"
type: "tech"
topics: ["Scala", "Extensible Effects", "é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°"]
published: false
---

# ã¯ã˜ã‚ã«

çŠ¶æ…‹ã‚’æ‰±ã†æ–¹æ³•ã¨ã—ã¦Stateãƒ¢ãƒŠãƒ‰ãŒã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã€‚Extensible Effectsã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã§ã‚ã‚‹[atnos-eff](https://github.com/atnos-org/eff/)ãŒæ¨™æº–ã§`State`ãŒæä¾›ã•ã‚Œã¦ã„ã‚‹ãŒã€ã“ã‚Œã¯æ¬¡ã®ã‚ˆã†ã«å¾®å¦™ãªç‚¹ãŒã‚ã‚‹ã€‚

1. [Cats](https://typelevel.org/cats/)ã®`State`ã‚’ãã®ã¾ã¾`Eff`ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã¸ä¹—ã›ã¦ã„ã‚‹[^cats-state]ãŒã€ãã†ã™ã‚‹å¿…è¦ã¯ãªã„
2. `State`ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼å†…ã§ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãª`var`å¤‰æ•°ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹[^var]

ã“ã®2ç‚¹ã¯å®Ÿéš›ä½¿ã†ä¸Šã§å®Ÿå®³ãŒã‚ã‚‹ã‚ã‘ã§ã¯**ãªã„**[^no_problem]ãŒã€ã›ã£ã‹ããªã®ã§å®Œå…¨ã«ç´”ç²‹ãªStateã‚’atons-effã§ä½œã£ãŸã»ã†ãŒã„ã„ã®ã§ã¯ãªã„ã‹ã¨ã„ã†ã“ã¨ã§ã€ã“ã®è¨˜äº‹ã§ã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã‚’åˆ©ç”¨ã—ãªã„Stateã®å®Ÿè£…ã‚’è€ƒãˆã¦ã„ãã€‚ã•ã‚‰ã«ãã®Stateå®Ÿè£…ã«å¯¾ã—ã¦[ScalaCheck](https://scalacheck.org/) + cats-lawsã§ãƒ¢ãƒŠãƒ‰å‰‡ã®ãƒ†ã‚¹ãƒˆã‚’ä¸ãˆã‚‹ã€‚

ãªãŠã€ã“ã®è¨˜äº‹ã«ã‚ã‚‹å®Œå…¨ãªã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ä¸‹è¨˜ã®GitHubãƒªãƒã‚¸ãƒˆãƒªãƒ¼ã‹ã‚‰å…¥æ‰‹ã§ãã‚‹ã€‚

- https://github.com/y-yu/atnos-eff-state

ã“ã®è¨˜äº‹ã¸ã®è³ªå•ã‚„ã‚³ãƒ¡ãƒ³ãƒˆãŒã‚ã‚Œã°æ°—è»½ã«æ•™ãˆã¦ã»ã—ã„ã€‚

[^cats-state]: https://github.com/atnos-org/eff/blob/68280574a80713a451c0e3b00945f6dfd37101df/shared/src/main/scala/org/atnos/eff/StateEffect.scala#L21-L39

[^var]: https://github.com/atnos-org/eff/blob/68280574a80713a451c0e3b00945f6dfd37101df/shared/src/main/scala/org/atnos/eff/StateEffect.scala#L93

[^no_problem]: Catsã®`State`ã‚’ç›´æ¥åˆ©ç”¨ã—ã¦ã„ã‚‹ã®ã§`get`/`put`ã®æŒ™å‹•ã‚’ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã§å¤‰æ›´ã—ãŸããªã£ãŸã¨ãã«é¢å€’ãªã“ã¨ã«ã¯ãªã‚‹ãŒã€ã§ããªã„ã‚ã‘ã§ã¯ãªã„ã¨æ€ã‚ã‚Œã‚‹ã€‚ã¾ãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ãŒã“ã“ã§åˆ©ç”¨ã—ã¦ã„ã‚‹ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«å¤‰æ•°ãŒè¤‡æ•°ã‚¹ãƒ¬ãƒƒãƒ‰ãªã©ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹å¯èƒ½æ€§ã‚‚ãªã„ã¨è€ƒãˆã‚‰ã‚Œã‚‹ã€‚

# Extensible Effectsã«ã‚ˆã‚‹`State`å®Ÿè£…

## DSLã®è¨­è¨ˆ

ã¾ãšCatsã®`State`ã¨ã¯åˆ¥ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã™ã‚‹ã€‚

```scala:StateTypes.scala
sealed trait State[S, A]

object State {
  case class Get[S]() extends State[S, S]

  case class Set[S](value: S) extends State[S, Unit]
}
```

`State`ã¯2ã¤ã®å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼`S`ã¨`A`ã‚’æŒã¡ã€ãã‚Œãã‚Œ**çŠ¶æ…‹ã®å‹**ã¨**çµæœã®å‹**ã¨ãªã‚‹ã€‚ãƒ¢ãƒŠãƒ‰`moand: M[A]`ã«ãŠã„ã¦çµæœã®å‹ã¯`A`ã¨ãªã‚‹ãŒã€ã“ã®`A`ãŒ`for (a <- monad)`ã¨ã„ã†ã‚ˆã†ãª`for`å¼ã‚’æ›¸ã„ãŸã¨ãå·¦è¾ºã®å¤‰æ•°`a`ã®å‹ã¨ãªã‚‹ã€‚
ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã¨ã—ã¦å®šç¾©ã•ã‚ŒãŸ`Get`/`Set`ã¯ãã‚Œãã‚Œæ¬¡ã®ã‚ˆã†ã«ãªã‚‹

- `Get`ã¯ç¾åœ¨ã®çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹DSLã§ã‚ã‚Šã€ãã®ãŸã‚`State[S, S]`ã®ã‚ˆã†ã«çµæœã®å‹ = çŠ¶æ…‹ã®å‹ã¨ãªã‚‹
- `Set`ã¯æ–°ã—ã„çŠ¶æ…‹ã‚’ã‚»ãƒƒãƒˆã™ã‚‹DSLã§ã‚ã‚Šã€çŠ¶æ…‹ã®æ›´æ–°ã¯ãƒ¢ãƒŠãƒ‰ã¨ã—ã¦ã®çµæœãŒãªã„ãŸã‚çµæœã®å‹ã¯`Unit`ã¨ãªã‚‹

## å‹ãƒ¬ãƒ™ãƒ«ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¼å®šç¾©

atnos-effã‚’ã¯ã˜ã‚ã¨ã™ã‚‹Extensible Effectsã§ã¯å‹ãƒ¬ãƒ™ãƒ«ãƒªã‚¹ãƒˆã®ã‚ˆã†ãªæ§‹é€ ã«ä¸Šè¨˜ã®`Get`ã¨ã„ã£ãŸå‹ã‚’ä¹—ã›ã‚‹ã“ã¨ã«ãªã‚‹ã€‚ã“ã®ã‚ˆã†ãªå‹ãƒ¬ãƒ™ãƒ«ãƒªã‚¹ãƒˆã‚’**ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¹ã‚¿ãƒƒã‚¯**ã¨å‘¼ã¶ã“ã¨ãŒã‚ã‚‹ãŒã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã«ç‹™ã£ãŸå‹ãŒã‚ã‚‹ã®ã‹ï¼Ÿã¨ã„ã†ã‚ˆã†ãªã“ã¨ã‚’ãƒã‚§ãƒƒã‚¯ã—ãŸããªã‚‹ãŸã‚ã€ãã†ã„ã†ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¼ã‚’ä½œã£ã¦ãŠãã€‚

### ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã®åˆ¶ç´„

```scala:StateTypes.scala
trait StateTypes {
  type _state[S, R] = State[S, *] /= R
}
```

ã“ã®`_state`ã¯[kind-projector](https://github.com/typelevel/kind-projector)ã®åˆ©ç”¨ã‚’å‰æã¨ã—ã¦æ¬¡ã®ã‚ˆã†ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚

```scala
def something[R: _state[Int, *]](): Eff[R, Unit]
```

ã“ã†ã™ã‚‹ã“ã¨ã§ä¸Šè¨˜ã®ä¾‹ã§ã„ãˆã°`something`ã®è¿”ã‚Šå€¤ã®å‹ã§ã‚ã‚‹`Eff[R, Unit]`ã«çŠ¶æ…‹ã«å¯¾ã™ã‚‹å‡¦ç†ãŒå¿…è¦ã§ã‚ã‚‹ã“ã¨ã‚’åˆ¶ç´„ã§ãã‚‹ã€‚

### ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã¸ã®è¿½åŠ 

`for`å¼ãªã©ã§ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€æ¬¡ã®`get`/`set`ã¨ã„ã†ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¼ã‚’ä½œã£ã¦ãŠãã€‚

```scala:StateCreation.scala
trait StateCreation extends StateTypes {
  def get[S, R: _state[S, *]]: Eff[R, S] =
    Eff.send[State[S, *], R, S](State.Get())

  def set[S, R: _state[S, *]](value: S): Eff[R, Unit] =
    Eff.send[State[S, *], R, Unit](State.Set(value))
}
```

ã“ã‚Œã‚’åˆ©ç”¨ã—ã¦æ¬¡ã®ã‚ˆã†ã«`for`å¼ã‚’çµ„ã¿ç«‹ã¦ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```scala
val eff: Eff[R, Int] = for {
  s1 <- get[Int, R]
  _ <- set[Int, R](1)
  s2 <- get[Int, R]
} yield s1 + num
```

## ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã®å®Ÿè£…

atons-effã¯`addLast`ã¨ã„ã†[Extensible Effectsã®å…ƒè«–æ–‡](https://okmij.org/ftp/Haskell/extensible/more.pdf)ã«ã¯ãªã„æ©Ÿæ§‹ã‚’ç‹¬è‡ªã«æ­è¼‰ã—ãŸã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã®ã‚ˆã†ãªä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã‚’ç‹¬è‡ªå®Ÿè£…ã™ã‚‹éš›ã«ã¨ã¦ã‚‚å†—é•·ã«ãªã£ã¦ã—ã¾ã†ã€‚`addLast`é–¢é€£ã¯ã„ã£ãŸã‚“ç„¡è¦–ã—ã¦ã€`StateInterpreter`ã‹ã‚‰æ„å‘³ãŒã‚ã‚‹éƒ¨åˆ†ã ã‘ã‚’æŠœãå‡ºã—ãŸã®ãŒä¸‹è¨˜ã®ã‚³ãƒ¼ãƒ‰ã¨ãªã‚‹ã€‚

```scala:StateInterpreter.scala
def runState[R, A, U, S](state: S)(eff: Eff[R, A])(implicit
  m1: Member.Aux[State[S, *], R, U]
): Eff[U, (A, S)] = {
  def interpretContinuation[X](
    s: S,
    c: Continuation[R, X, A]
  ): Continuation[U, X, (A, S)] =
    Continuation.lift { (x: X) =>
      runState(s)(c(x))
    }


  eff match {
    case Pure(a, last) =>
      Eff.pure((a, state))

    case Impure(NoEffect(a), c, last) =>
      Impure(
        NoEffect(a),
        interpretContinuation(state, c),
      )

    case Impure(u: Union[_, _], c, last) =>
      m1.project(u) match {
        case Right(tu) =>
          tu match {
            case State.Get() =>
              Eff.impure(state, interpretContinuation(state, c))

            case State.Set(value) =>
              Eff.impure((), interpretContinuation(value, c))
          }

        case Left(other) =>
          Impure(other, interpretContinuation(state, c))
      }
  }
}
```

[atnos-effã®`Interpret.runInterpreter`](https://github.com/atnos-org/eff/blob/master/shared/src/main/scala/org/atnos/eff/Interpret.scala)ã¨å†å¸°ã®ä»•æ–¹ãŒä¼¼ã¦ã„ã‚‹ãŒã€`runInterpreter`ã¯ä¸€èˆ¬åŒ–ã—ãŸãŸã‚`runState`ã®ã‚ˆã†ã«ã€Œæ¬¡ã®çŠ¶æ…‹ã€ã‚’å¼•æ•°ã§å¼•ãå›ã™ã“ã¨ãŒã§ããªã„ã€‚ã—ãŸãŒã£ã¦atons-effã«ãŠã‘ã‚‹`StateInterpretation`ã®å®Ÿè£…ã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãª`var`ã‚’åˆ©ç”¨ã›ã–ã‚‹ã‚’å¾—ãªã‹ã£ãŸã‚‚ã®ã¨æ€ã‚ã‚Œã‚‹[^impureAp]ã€‚

[^impureAp]: ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯çœç•¥ã—ãŸãŒatnos-effã§ã¯`ImpureAp`ã¨ã„ã† _Freer Applicative_ ã¨ã‚‚è¨€ãˆã‚‹ã‚ˆã†ãªæ©Ÿèƒ½ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã€‚ã—ã‹ã—åŠ¹ç‡åŒ–ã®ãŸã‚ãªã®ã‹ã€ãã‚Œã¨ã‚‚Scalaã®å‹ã‚·ã‚¹ãƒ†ãƒ ã®éƒ½åˆãªã®ã‹`Any`ãªã©ã§å‹ã‚¨ãƒ©ãƒ¼ã‚’å›é¿ã—ãŸç®‡æ‰€ãŒå¤§é‡ã«ã‚ã‚Šã€å°‘ã—å¤±æ•—ã—ãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã‚’æ›¸ãã¨ã™ãã«ãƒ©ãƒ³ã‚¿ã‚¤ãƒ å‹ã‚¨ãƒ©ãƒ¼ãŒç”Ÿã˜ã‚‹ã€‚`Interpret.runInterpreter`ã‚’ä½¿ãˆã°`ImpureAp`ãªã©ãƒ‡ãƒ¼ã‚¿æ§‹é€ `Eff`ã®å…·ä½“çš„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«å¯¾ã—ã¦ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã—ãªãã¦æ¸ˆã‚€ãŸã‚ã€ã“ã®ã‚ˆã†ãªå‹çš„ã«ã‚¢ãƒ³ã‚»ãƒ¼ãƒ•ãªéƒ¨åˆ†ã‚’éš è”½ã—ã¦ãŠããŸã„ã¨ã„ã†æ€æƒ‘ãŒã‚ã£ãŸã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚

# ScalaCheckã¨cats-lawsã«ã‚ˆã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ

ã“ã“ã§ä½œã£ãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ãŒå‹•ä½œã—ã¦ã„ã‚‹ã®ã‹ã‚’**ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ**ã—ã¦ã„ãã€‚ã“ã“ã§ã¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã‚’æ¬¡ã®`R`ã«å›ºå®šã—ã¦è¡Œã†ã€‚

```scala:StateLawsTest.scala
type R = Fx.fx1[State[Int, *]]
```

ã“ã®ã‚ˆã†ã«çŠ¶æ…‹ã®å‹ã¯`Int`ã«å›ºå®šã§è¡Œã†ã€‚

## `Arbitrary[Eff[R, A]]`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å®šç¾©

ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã¯ãƒ©ãƒ³ãƒ€ãƒ ã«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œã‚Šã€ãã®ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦æ“ä½œã‚’é©ç”¨ã—ãŸã‚ã¨ã§çµæœãŒäºˆå®šã•ã‚ŒãŸæ€§è³ªï¼ˆãƒ¢ãƒŠãƒ‰å‰‡ãªã©ï¼‰ã‚’æº€ã—ã¦ã„ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã€‚ã“ã®ãŸã‚ã¾ãšã¯ä»Šå›ä½œæˆã—ãŸ`Eff[R: _state[S, *], A]`ã¨ã„ã†ã‚ˆã†ãªå‹ã‚’æŒã¤ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹ãŸã‚ã®`Arbitrary[Eff[R, A]]`ã®ã‚¤ãƒ³ã‚¹ãƒ³ã‚¿ãƒ³ã‚¹å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

```scala:StateLawsTest.scala
implicit def genState[A: Arbitrary](implicit
  aInt: Arbitrary[Int]
): Arbitrary[Eff[R, A]] =
  Arbitrary(
    Gen.frequency(
      1 -> Arbitrary.arbitrary[A].map(Eff.pure[R, A]),
      1 -> Arbitrary.arbitrary[A].map { x =>
        for {
          s <- StateEffect.get[Int, R]
          newState = s + 1
          _ <- StateEffect.set(newState)
        } yield x
      }
    )
  )
```

è‡ªå‹•ç”Ÿæˆã‚’ã©ã†ã„ã†ãµã†ã«ã—ã¦ã‚‚ã„ã„ãŒæ¬¡ã®ã‚ˆã†ãª2ç¨®é¡ã®å€¤ãŒ$1 : 1$ã®å‰²åˆã§ç”Ÿæˆã•ã‚Œã‚‹ã‚ˆã†ã«ã—ãŸã€‚

- ä»»æ„ã®å‹`A`ã®å€¤ã‚’`Eff.pure`ã§æŒã¡ä¸Šã’ãŸå€¤
- `get`ã§çŠ¶æ…‹`s`ã‚’å–å¾—ã—ãŸå¾Œã€ãã‚Œã«1ã‚’è¶³ã—ç®—ã—ãŸå€¤$s + 1$ã§çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¤ã¤å‹`A`ã®å€¤ã‚’çµæœã¨ã™ã‚‹å€¤

## æ¯”è¼ƒç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹`Eq[Eff[R, A]]`

ãƒ©ãƒ³ãƒ€ãƒ ç”ŸæˆãŒã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã¨ã“ã‚ã§ã€æ¬¡ã¯æ¯”è¼ƒã®ãŸã‚ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹`Eq[Eff[R, A]]`ã‚’ä½œã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

```scala
implicit def equalState[A](implicit
  eq: Eq[(A, Int)]
): Eq[Eff[R, A]] =
  Eq.by { (eff: Eff[R, A]) =>
    Eff
      .run(
        eff.runState(default)
      )
  }
```

ã“ã‚Œã¯å˜ç´”ã«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã‚’èµ·å‹•ã—ã¦å¾—ã‚‰ã‚ŒãŸçŠ¶æ…‹ã¨çµæœã®ä¸¡æ–¹ï¼ˆã‚¿ãƒ—ãƒ«å€¤ï¼‰ãŒç­‰ã—ã‘ã‚Œã°ç­‰ã—ã„ã¨ã¿ãªã™ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ãªã‚‹ã€‚

## ãƒ¢ãƒŠãƒ‰å‰‡ã®æ¤œæŸ»

ã‚ã¨ã¯cats-lawsã«å…¥ã£ã¦ã„ã‚‹`MonadTests`ã‚’åˆ©ç”¨ã™ã‚Œã°ã‚ˆã„ã€‚catsç”¨ã®`Monad`ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯atons-effãŒæä¾›ã—ã¦ã„ã‚‹ã‚‚ã®ã‚’ä½¿ãˆã°ã‚ˆã„ã€‚

```scala
import Eff.EffMonad

def checkAll(props: Seq[(String, Prop)]): Unit = {
  for ((name2, prop) <- props) yield {
    property(name + ":" + name2) = prop
  }
}

checkAll(MonadTests[Eff[R, *]].monad[Int, Int, Int].props)
checkAll(ApplicativeTests[Eff[R, *]].applicative[Int, Int, Int].props)
```

ã¤ã„ã§ã«`ApplicativeTests`ã§ã‚¢ãƒ—ãƒªã‚«ãƒ†ã‚£ãƒ–å‰‡ã‚‚ãƒ†ã‚¹ãƒˆã•ã›ã¦ã¿ã‚‹ã€‚ã“ã‚Œã‚’`sbt test`ã™ã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ã€‚

```
sbt:atnos-eff-state> test
[info] Formatting 1 Scala sources...
[info] compiling 1 Scala source to /Users/yyu/Desktop/atnos-eff-state/target/scala-2.13/test-classes ...
[info] + StateLaws.StateLaws:tailRecM stack safety: OK, proved property.
[info] + StateLaws.StateLaws:applicative unit: OK, passed 100 tests.
[info] + StateLaws.StateLaws:map flatMap coherence: OK, passed 100 tests.
[info] + StateLaws.StateLaws:monad left identity: OK, passed 100 tests.
[info] + StateLaws.StateLaws:monoidal left identity: OK, passed 100 tests.
[info] + StateLaws.StateLaws:monad right identity: OK, passed 100 tests.
[info] + StateLaws.StateLaws:monoidal right identity: OK, passed 100 tests.
[info] + StateLaws.StateLaws:applicative identity: OK, passed 100 tests.
[info] + StateLaws.StateLaws:applicative homomorphism: OK, passed 100 tests.
[info] + StateLaws.StateLaws:applicative map: OK, passed 100 tests.
[info] + StateLaws.StateLaws:applicative interchange: OK, passed 100 tests.
[info] + StateLaws.StateLaws:ap consistent with product + map: OK, passed 100 tests.
[info] Passed: Total 12, Failed 0, Errors 0, Passed 12
[success] Total time: 14 s, completed 2021/11/20 23:56:30
```

# ã¾ã¨ã‚

æ¥­å‹™ã§çŠ¶æ…‹ã‚’ä½¿ã†ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ãŒæ¬²ã—ããªã£ãŸã‚‚ã®ã®ã€atnos-effã®å®Ÿè£…ã§ã¯çŠ¶æ…‹ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ãŒå¤‰ã ã¨æ€ã„è‡ªåŠ›ã§ä½œã£ã¦ã¿ã‚‹ã“ã¨ã«ã—ãŸã€‚ã—ã‹ã—`ImpureAp`ã®å†…éƒ¨æ§‹é€ ã§ã‚ã£ãŸã‚Š`addLast`ã®æ‹¡å¼µã«ã‚ˆã£ã¦ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã¯æœ¬è³ªçš„ã§ãªã„ã¨ã“ã‚ã§è‚¥å¤§åŒ–ã—ãŸã¨ã„ã†å°è±¡ãŒã‚ã‚‹ã€‚ãŸã—ã‹ã«ä¸¦è¡Œãƒ»ä¸¦åˆ—ã®ã“ã¨ãªã©ã‚’è€ƒãˆã‚‹ã¨`ImpureAp`ãŒå¿…è¦ã§ã‚ã‚‹ã“ã¨ã‚‚ç†è§£ã§ãã‚‹ã—ã€ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ãªã©ã§`addLast`ãŒã‚ã£ãŸã»ã†ãŒã„ã„ã“ã¨ã‚‚ã‚ã‚‹ã‚‚ã®ã®ã€ã“ã“ã¾ã§è¤‡é›‘ã¨ãªã‚‹ã¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã‚’æ›¸ãã®ã¯å¤§å¤‰ã§ã‹ã¤ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¨ãƒ©ãƒ¼ã®å±é™ºãŒã¤ãã¾ã¨ã†ä¸€ã‹å…«ã‹ã®ä½œæ¥­ã¨è¨€ã‚ã–ã‚‹ã‚’å¾—ãªã„ã€‚atons-effã®æ–¹å‘æ€§ã¯ã“ã‚Œã¯ã“ã‚Œã§ã„ã„ã¨ã—ã¦ã€ã‚‚ã£ã¨åŸç†ä¸»ç¾©çš„ãªExtensible Effectsã®å®Ÿè£…ãŒã‚ã‚Œã°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã‚’ã‚‚ã£ã¨ã‚·ãƒ³ãƒ—ãƒ«ã«å®Ÿè£…ã§ãã‚‹ã¨æ€ã†ã€‚
ã¾ãŸä»Šå›ã¯ã˜ã‚ã¦ScalaCheck + cats-lawsã«ã‚ˆã‚‹ãƒ¢ãƒŠãƒ‰å‰‡ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã—ã¦ã¿ãŸã€‚[scalaprops](https://github.com/scalaprops/scalaprops)ã§ã®çµŒé¨“ãŒå¤šå°‘ã‚ã£ãŸãŸã‚ã€æ¯”è¼ƒçš„ç°¡å˜ã«æ›¸ãã“ã¨ãŒã§ããŸãŒã‚‚ã†å°‘ã—ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒã‚ã£ã¦ã‚‚ã„ã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚

# å‚è€ƒæ–‡çŒ®

- [ç¢ºç‡ãƒ¢ãƒŠãƒ‰ã® Cats å®Ÿè£…ã¨ãƒ¢ãƒŠãƒ‰å‰‡ã® Discipline ãƒ†ã‚¹ãƒˆ](https://qiita.com/yasuabe2613/items/e0eff5973a70b5b8968c)
    - cats-lowsã®ã“ã¨ãŒæ›¸ã„ã¦ã‚ã‚‹æ—¥æœ¬èªè¨˜äº‹ã§ã€è‡ªåˆ†ã§ä¸€é€šã‚Šã‚„ã£ãŸã‚ã¨ã«ç™ºè¦‹ã—ãŸãŒã€ã¯ã˜ã‚ã«èª­ã‚“ã§ãŠã‘ã°ã‚‚ã£ã¨ç°¡å˜ã«ãªã£ãŸã¨æ€ã†â€¦â€¦